# Name: Nicolas Urrea
# Date: October 31, 2024
# Assignment: Assignment 4
# Due Date: October 30, 2024, 11:59 PM
# About this project: This program creates a tic-tact-toe game. The server file sets up a connection, manages the Tic-Tac-Toe game state, and alternates turns with the client until a player wins or the game ties.
# Assumptions: Pretty much assumes players take turns in order, the server waits for new connections after each game, moves follow the [ABC][123] format, and the network is stable.
# All work below was performed solely by Nicolas Urrea.
# I used code generated by an AI tool.

import socket
import sys

def print_board(board):
    print("  1 2 3")
    print("A " + " ".join(board[0]))
    print("B " + " ".join(board[1]))
    print("C " + " ".join(board[2]))

def check_win(board, symbol):
    # Check rows, columns, and diagonals for a win
    for row in board:
        if all(cell == symbol for cell in row):
            return True
    for col in range(3):
        if all(board[row][col] == symbol for row in range(3)):
            return True
    if board[0][0] == board[1][1] == board[2][2] == symbol or \
       board[0][2] == board[1][1] == board[2][0] == symbol:
        return True
    return False

def board_full(board):
    return all(cell != '.' for row in board for cell in row)

def server_program(port):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', port))
    server_socket.listen(1)
    print(f"Server started on port {port}. Waiting for opponent to connect...")

    while True:
        client_socket, client_address = server_socket.accept()
        print(f"Received opponent connection from {client_address}")
        
        board = [['.' for _ in range(3)] for _ in range(3)]
        print_board(board)
        
        game_over = False
        server_symbol = 'O'
        client_symbol = '#'
        
        while not game_over:
            print("Waiting for opponent's first move...")
            move = client_socket.recv(1024).decode()
            if not move:
                break
            
            row, col = ord(move[0].upper()) - 65, int(move[1]) - 1
            if board[row][col] == '.':
                board[row][col] = client_symbol
                print_board(board)
                if check_win(board, client_symbol):
                    print("Your opponent won the game!")
                    client_socket.send("win".encode())
                    game_over = True
                elif board_full(board):
                    print("The game is a tie!")
                    client_socket.send("tie".encode())
                    game_over = True
                else:
                    client_socket.send("continue".encode())
            else:
                client_socket.send("invalid".encode())
                continue

            if game_over:
                break
            
            while True:
                try:
                    move = input("Your move ([ABC][123]): ").upper()
                    row, col = ord(move[0]) - 65, int(move[1]) - 1
                    if board[row][col] == '.':
                        board[row][col] = server_symbol
                        client_socket.send(move.encode())
                        print_board(board)
                        break
                    else:
                        print("Invalid move, position already taken.")
                except (IndexError, ValueError):
                    print("Invalid input format. Use format [ABC][123].")

            if check_win(board, server_symbol):
                print("Congratulations, you won!")
                client_socket.send("lose".encode())
                game_over = True
            elif board_full(board):
                print("The game is a tie!")
                client_socket.send("tie".encode())
                game_over = True

        client_socket.close()
        print("Waiting for opponent to connect...")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python lastname_firstinitial_tictactoeserver.py <port>")
        sys.exit(1)
    port = int(sys.argv[1])
    server_program(port)
